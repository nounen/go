## 更多类型
* 指针, struct, slice, 映射


### 指针 (pointer)
* __指针__ 保存了 __值的内存地址__

* 类型 `*T` 是指向 `T` 类型值的指针。其零值为 `nil`

* 声明指针: `var p *int` // fmt.Println(p) 得到 `<nil>`

* __`&` 操作符__: 会生成一个指向其操作数的指针
    * 生成指针 (即值的内存地址)
    
    * eg:
    ```go
    i := 1
    fmt.Println(&i) // 得到 `0xc420016108` 指针保存了值的内存地址 
    ```

* __`*` 操作符__: 表示指针指向的底层值
    * 指向指针所在的值
    
    * eg:
    ```go
    i := 1
    fmt.Println(*&i) // 得到 `1`: 先取地址(先得到一个指针), 再指向地址所在的值
    ```

* Go _没有指针运算_


### 结构体 (struct)
* 一个结构体（struct）就是 __一个字段__ 的集合

* 声明结构体: `type Xxx struct { ... }`

* 访问结构体字段: 结构体字段使用 _点号_ 来访问

* 结构体指针:
    * 结构体字段可以通过结构体指针来访问

    * 如果我们有一个指向结构体的指针 `p`，那么可以通过 `(*p).X` 来访问其字段 `X`

    * eg:
    ```go
    v := Vertex{1, 2}

	fmt.Println(v) // {1 2}
    fmt.Println(&v) // &{1 2}
    ```

* 结构体文法:
    * 赋值: 结构体文法通过直接列出字段的值来新分配一个结构体

    * 使用 Name: 语法可以仅列出部分字段。（字段名的顺序无关。）

    * 没有赋值的字段默认使用数据类型对应的 _零值_

    * __特殊__ 的前缀 `&` 返回一个指向结构体的指针(参考上面 `fmt.Println(&v) // &{1 2}`)


### 数组 (array)
* 类型 `[n]T` 表示拥有 `n` 个 `T` 类型的值的数组
    * 类型依旧放变量后面

* 数组的长度是其类型的一部分，因此 __数组不能改变大小__ (所以有了 _切片_ slice 类型)

* 数组批量赋值: `primes := [6]int{2, 3, 5, 7, 11, 13}`


### 切片 (slice)
* 每个数组的大小都是固定的。而 __切片则为数组元素提供动态大小的、灵活的视角__。在实践中，切片比数组更常用

* 类型 `[]T` 表示一个元素类型为 `T` 的切片:
    * 只要 _数组不指定长度就是切片_

* 切片通过两个下标来界定，即一个上界和一个下界，二者以冒号分隔：
    * `a[low : high]`

    * 它会选择一个半开区间，__包括第一个元素，但排除最后一个元素__ (左闭右开)

* eg: `a[1:4]` 表达式创建了一个切片，它包含 a 中下标从 1 到 3 的元素

* 切片就像数组的引用:
    * __切片并不存储任何数据，它只是描述了底层数组中的一段__

    * 更改切片的元素会修改其底层数组中对应的元素 (引用类型?)

* 切片的默认行为:
    * 切片下界的默认值为 0，上界则是该切片的长度

    * 对于数组 `var a [10]int`, 一下切片都是等价的:
    ```go
    a[0:10]
    a[:10]
    a[0:]
    a[:]
    ```

* 切片的 _长度_ 与 _容量_:
    * 切片拥有 长度 和 容量。

    * 切片的 __长度__ 就是它所包含的元素个数。

    * 切片的 __容量__ 是从它的第一个元素开始数，到其 _底层数组元素末尾的个数_。

    * 切片 `s` 的长度和容量可通过表达式 `len(s)` 和 `cap(s)` 来获取

    * 切片本身可以继续扩展切片

* nil 切片:
    * 切片的零值是 `nil`

    * nil 切片的长度和容量为 0 且没有底层数组

* 用 `make` 创建切片:
    * 切片可以用内建函数 `make` 来创建，这也是你 __创建动态数组的方式__

* `make` 函数会分配一个元素为零值的数组 __并__ 返回一个 _引用了它的切片_
    * eg: `a := make([]int, 5)  // len(a)=5`

    * 要指定它的 _容量_，需向 `make` 传入第三个参数：`b := make([]int, 0, 5) // len(b)=0, cap(b)=5`

* 切片的切片: 
    * 切片可包含任何类型，甚至包括其它的切片

* 向切片追加元素:
    * 使用内建的 `append` 函数

    * `func append(s []T, vs ...T) []T`

* Range:
    * `for ... range` 形式可遍历 _切片_ 或 _映射_

    * 当使用 `for ... range` 循环遍历切片时，每次迭代都会返回两个值。第一个值为当前元素的下标，第二个值为该下标所对应元素的一份副本

    * 可以将下标或值赋予 `_` 来忽略它

    * eg: `for _, value := range pow {...}`



### 映射 (map)
* 映射将 __键__ 映射到 __值__

* 零值: 映射的零值为 `nil` 。`nil` 映射既没有键，也不能添加键。

* __`make` 函数__ 会返回给定类型的映射，并将其初始化备用
    * 视乎 `make()` 函数可以干不少事情, 文档介绍: 
        * `make` 内建函数分配并初始化一个类型为切片、映射、或（仅仅为）信道的对象。 
        * 与 `new` 相同的是，其第一个实参为类型，而非值。
        * 不同的是，`make` 的返回类型 与其参数相同，而非指向它的指针。

* eg: 看着怪怪的 
    ```go
    var m = make(map[string]int)
    m["key1"] = 1
    ```

* 映射的文法:
    * 映射的文法与结构体相似，不过 __必须有键名__
    * 若顶级类型只是一个类型名，你可以在文法的元素中省略它

* map 相关操作:
    * 修改元素: `m[key] = elem`
    * 获取元素: `elem = m[key]`
    * 删除元素: `delete(m, key)`
    * 通过双赋值检测某个键是否存在: `elem, ok = m[key]`:
        * 若 `key` 在 `m` 中，`ok` 为 `true`； 否则，`ok` 为 `false`

        * 若 `key` 不在映射中，那么 `elem` 是该映射元素类型的 _零值_

        * 同样的，当从 映射 中读取某个不存在的键时，结果是 映射 的元素类型的 零值

        * 注 ：若 elem 或 ok 还未声明，你可以使用短变量声明: `elem, ok := m[key]`
    
    