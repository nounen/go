## 6.1 介绍
* Go 里面有三种类型的函数：
    * 普通的带有名字的函数
    * 匿名函数或者 lambda 函数（参考 第 6.8 节）
    * 方法（Methods，参考 第 10.6 节）

* 格式:
```go
// 它必须是这样的：

func g() {
}
```

* 除了 `main()`、`init()` 函数外，其它所有类型的函数都可以有参数与返回值。函数参数、返回值以及它们的类型被统称为 _函数签名_

* 函数也可以以申明的方式被使用，作为一个 __函数类型__
    * eg: `type binOp func(int, int) int`

* 函数是 __一等值__（first-class value）：它们可以赋值给变量


## 6.2 函数参数与返回值
* 6.2.1 按值传递（call by value） 按引用传递（call by reference）
    * Go 默认使用按值传递来传递参数，也就是传递参数的副本

    * 如果你希望函数可以直接修改参数的值，而不是对参数的副本进行操作，你需要将参数的地址（变量名前面添加 `&` 符号，比如 `&variable`）传递给函数，这就是按引用传递，
        * 比如调用 `Function(&arg1)`，此时传递给函数的是一个 _指针_
    
    * _指针_ 也是变量类型，有自己的地址和值，通常指针的值指向一个变量的地址。所以，_按引用传递也是按值传递_。

    * 在函数调用时，像切片（slice）、字典（map）、接口（interface）、通道（channel）__这样的引用类型都是默认使用引用传递（即使没有显式的指出指针）__

* 6.2.2 命名的返回值（named return variables）
    ```go
    // 命名返回值 【推荐】
    func getX2AndX3(input int) (int, int) {
        return 2 * input, 3 * input
    }

    // 非命名返回值 【不推荐】
    func getX2AndX3_2(input int) (x2 int, x3 int) {
        x2 = 2 * input
        x3 = 3 * input
        // 等价于 return x2, x3
        return
    }
    ```

* 6.2.3 空白符（blank identifier）
    * 空白符(`_`)用来匹配一些不需要的值，然后丢弃掉

* 6.2.4 改变外部变量（outside variable）
    * _传递指针给函数_ 不但可以节省内存（因为没有复制变量的值），而且赋予了函数直接修改外部变量的能力，所以被修改的变量不再需要使用 `return` 返回


## 6.3 传递变长参数
* 如果函数的 _最后一个参数_ 是采用 `...type` 的形式，那么这个函数就可以处理一个变长的参数，这个长度可以为 0

* 如果变长参数的类型并不是都相同的呢？使用 5 个参数来进行传递并不是很明智的选择，有 2 种方案可以解决这个问题：
    1. 使用结构 (`struct`);

    2. 使用空接口(`interface{}`);


## 6.4 defer 和追踪
* 使用 defer 语句实现代码追踪

* 使用 defer 语句来记录函数的参数与返回值


## 6.5 内置函数
```go
名称	                说明

close	                用于管道通信

len、cap	            len 用于返回某个类型的长度或数量（字符串、数组、切片、map 和管道）；cap 是容量的意思，用于返回某个类型的最大容量（只能用于切片和 map）

new、make	            new 和 make 均是用于分配内存：new 用于值类型和用户定义的类型，如自定义结构，make 用于内置引用类型（切片、map 和管道）。它们的用法就像是函数，但是将类型作为参数：new(type)、make(type)。new(T) 分配类型 T 的零值并返回其地址，也就是指向类型 T 的指针（详见第 10.1 节）。它也可以被用于基本类型：v := new(int)。make(T) 返回类型 T 的初始化之后的值，因此它比 new 进行更多的工作（详见第 7.2.3/4 节、第 8.1.1 节和第 14.2.1 节）new() 是一个函数，不要忘记它的括号

copy、append	用于复制和连接切片

panic、recover	两者均用于错误处理机制

print、println	底层打印函数（详见第 4.2 节），在部署环境中建议使用 fmt 包

complex、real imag	用于创建和操作复数（详见第 4.5.2.2 节）
```


## 6.6 递归函数
* 许多问题都可以使用优雅的递归来解决，比如说著名的 _快速排序算法_

* 在使用递归函数时经常会遇到的一个重要问题就是栈溢出：一般出现在大量的递归调用导致的程序栈内存分配耗尽。
    * 这个问题可以通过一个名为 __懒惰求值的技术__ 解决，在 Go 语言中，我们可以使用管道（channel）和 goroutine（详见第 14.8 节）来实现。


## 6.7 将函数作为参数
* eg
    ```go
    func callback(y int, f func(int, int)) {
        f(y, 2) // this becomes Add(1, 2)
    }
    ```


## 6.8 闭包
* defer 语句和匿名函数
    * 匿名函数同样被称之为闭包（函数式语言的术语）：它们被允许调用定义在其它环境下的变量。
