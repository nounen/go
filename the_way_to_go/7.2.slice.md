## 7.2 切片


### 7.2.1 概念
* **切片**（slice）是 *对数组一个连续片段的引用*（该数组我们称之为相关数组，通常是匿名的），所以切片是一个 *引用类型*

* 切片是可索引的，并且可以由 `len()` 函数获取长度

* 与数组不同的是，切片的长度可以在运行时修改：切片是一个 **长度可变的数组**

* 切片提供了计算容量的函数 `cap()` 可以测量切片最长可以达到多少：它等于切片的长度 + 数组除切片之外的长度
    * 如果 s 是一个切片，cap(s) 就是从 s[0] 到数组末尾的数组长度。
    * 切片的长度永远不会超过它的容量，所以对于 切片 s 来说该不等式永远成立：0 <= len(s) <= cap(s)。

* 声明切片的格式是： `var identifier []type`（不需要说明长度）    
    * 一个切片在未初始化之前默认为 nil，长度为 0

* 切片的初始化格式是：`var slice1 []type = arr1[start:end]`

* 切片在内存中的组织方式实际上是一个有 3 个域的结构体：指向相关数组的指针，切片 长度以及切片容量
    * http://wiki.jikexueyuan.com/project/the-way-to-go/images/7.2_fig7.2.png

* **注意** 绝对不要用指针指向 slice。切片本身已经是一个引用类型，所以它本身就是一个指针!!    


### 7.2.2 将切片传递给函数


### 7.2.3 用 make() 创建一个切片
* 当相关数组还没有定义时，我们可以使用 make() 函数来创建一个切片 同时创建好相关数组：
    * `var slice1 []type = make([]type, len)`

    * 也可以简写为 `slice1 := make([]type, len)`，这里 `len` 是数组的长度并且也是 `slice` 的初始长度 (TODO: 说好的 slice 是变长数组, 怎么就要指定 len 了?)

* 面两种方法可以生成相同的切片:
```go
make([]int, 50, 100)
new([100]int)[0:50]
```


### 7.2.4 new() 和 make() 的区别
* 看起来二者没有什么区别，都在堆上分配内存，但是它们的行为不同，适用于不同的类型

* `new(T)` 为每个新的类型T分配一片内存，初始化为 0 并且返回类型为 *T 的 *内存地址*：这种方法 **返回一个指向类型为 T，值为 0 的地址的指针**，它适用于值类型如数组和结构体（参见第 10 章）；它相当于 `&T{}`。

* `make(T)` **返回一个类型为 T 的初始值**，它只适用于3种内建的引用类型：切片、map 和 channel（参见第 8 章，第 13 章）。

* 换言之，new 函数分配内存，make 函数初始化；下图给出了区别：
    * http://wiki.jikexueyuan.com/project/the-way-to-go/images/7.3_fig7.3.png?raw=true



### 7.2.5 多维 切片


### 7.2.6 bytes 包