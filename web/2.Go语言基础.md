## 2 Go语言基础
* 25 个关键字
```go
break    default      func    interface    select
case     defer        go      map          struct
chan     else         goto    package      switch
const    fallthrough  if      range        type
continue for          import  return       var
```


### 2.1. 你好，Go
* 详解:
    * go 程序通过 `package` 来组织
        * `package <pkgName>`（在我们的例子中是package main）这一行告诉我们当前文件属于哪个包

        * 而包名main则告诉我们它是一个可独立运行的包，它在编译后会产生可执行文件

        * 除了main包之外，其它的包最后都会生成*.a文件（也就是包文件）并放置在$GOPATH/pkg/$GOOS_$GOARCH中

* Go是天生支持UTF-8的，任何字符都可以直接输出，你甚至可以用UTF-8中的任何字符作为标识符


### 2.2. Go基础
* 定义变量:
    ```go
    //定义一个名称为“variableName”，类型为"type"的变量
    var variableName type

    //定义三个类型都是“type”的变量
    var vname1, vname2, vname3 type

    //初始化“variableName”的变量为“value”值，类型是“type”
    var variableName type = value

    /*
    定义三个类型都是"type"的变量,并且分别初始化为相应的值
    vname1为v1，vname2为v2，vname3为v3
    */
    var vname1, vname2, vname3 type= v1, v2, v3

    /*
    定义三个变量，它们分别初始化为相应的值
    vname1为v1，vname2为v2，vname3为v3
    然后Go会根据其相应值的类型来帮你初始化它们 (不用强调类型)
    */
    var vname1, vname2, vname3 = v1, v2, v3

    /*
    定义三个变量，它们分别初始化为相应的值
    vname1为v1，vname2为v2，vname3为v3
    编译器会根据初始化的值自动推导出相应的类型
    */
    vname1, vname2, vname3 := v1, v2, v3
    ```

    * 简短声明: `:=` 这个符号直接取代了 var 和 type
        * 它有一个限制，那就是它 **只能用在函数内部**

        * 在函数外部使用则会无法编译通过，所以一般用var方式来定义 **全局变量**

    * `_`（下划线）是个 **特殊的变量名**，任何赋予它的值都会被丢弃
        * `_, b := 34, 35` 这里 34 被丢弃了

    * Go对于 **已声明但未使用的变量会在编译阶段报错** (包括 package)

* 常量:
    ```go
    const constantName = value
    //如果需要，也可以明确指定常量的类型：
    const Pi float32 = 3.1415926
    ```

* 内置基础类型
    * Boolean

    * 数值类型:
        * `rune, int8, int16, int32, int64` 和 `byte, uint8, uint16, uint32, uint64`
        
        * 其中 rune 是 int32 的别称，byte 是 uint8 的别称

        * Go还支持复数: 它的默认类型是 `complex128`（64位实数+64位虚数）
            * 复数的形式为 `RE + IMi`，其中 RE 是实数部分，IM 是虚数部分，而最后的i是虚数单位

            *
            ```go
            var c complex64 = 5+5i
            // output: (5+5i)
            fmt.Printf("Value is: %v", c)
            ```

* 字符串
    * Go中的字符串都是采用UTF-8字符集编码。
    
    * 字符串是用一对 *双引号*（""）或*反引号*（` `）括起来定义，它的类型是 string

    * 声明一个多行的字符串怎么办？可以通过`来声明
        * ` 括起的字符串为Raw字符串，即字符串在代码中的形式就是打印时的形式，它没有字符转义，换行也将原样输出

* 错误类型
    * Go内置有一个 `error` 类型，专门用来处理错误信息，Go 的 package 里面还专门有一个包 `errors` 来处理错误
        ```go
        err := errors.New("emit macho dwarf: elf header corrupted")
        if err != nil {
            fmt.Print(err)
        }
        ```

* 分组声明
```go
import(
	"fmt"
	"os"
)

const(
	i = 100
	pi = 3.1415
	prefix = "Go_"
)

var(
	i int
	pi float32
	prefix string
)
```

* iota枚举: 可以说是很蛋疼
    * TODO: 跳过


* **Go程序设计的一些规则**
    * 大写字母开头的变量是可导出的，也就是其它包可以读取的，是 *公有变量*；小写字母开头的就是不可导出的，是 *私有变量*

    * 大写字母开头的函数也是一样，相当于 `class` 中的带 `public` 关键词的公有函数；小写字母开头的就是有 `private` 关键词的私有函数

* array:
    * array 就是数组，它的定义方式如下：`var arr [n]type`

    * 长度也是数组类型的一部分

    * 数组之间的赋值是值的赋值，*即当把一个数组作为参数传入函数的时候，传入的其实是该数组的副本，而不是它的指针*。如果要使用指针，那么就需要用到后面介绍的 `slice` 类型了

    * 数组可以使用另一种 `:=` 来声明
    ```go
    a := [3]int{1, 2, 3} // 声明了一个长度为3的int数组

    b := [10]int{1, 2, 3} // 声明了一个长度为10的int数组，其中前三个元素初始化为1、2、3，其它默认为0

    c := [...]int{4, 5, 6} // 可以省略长度而采用`...`的方式，Go会 **自动根据元素个数来计算长度**
    ```

* slice
    * 我们就需要“动态数组”。在Go里面这种数据结构叫 `slice`

    * 声明 slice:
    ```go
    // 和声明array一样，*只是少了长度*
    var fslice []int
    ```

    * 注意 slice 和数组在声明时的区别
        * ：声明数组时，方括号内写明了数组的长度或使用 `...` 自动计算长度，而声明 slice 时，方括号内没有任何字符

    * slice 有一些简便的操作
        * slice 的默认开始位置是0，ar[:n] 等价于 ar[0:n]
        * slice 的第二个序列默认是数组的长度，ar[n:] 等价于 ar[n:len(ar)]
        * 如果从一个数组里面直接获取 slice，可以这样 `ar[:]`，因为默认第一个序列是0，第二个是数组的长度，即等价于ar[0:len(ar)]

    * slice 是 **引用类型**，所以当引用改变其中元素的值时，其它的所有引用都会改变该值    

    * 对于slice有几个有用的 *内置函数*
        * len 获取slice的长度
        * cap 获取slice的最大容量
        * append 向slice里面追加一个或者多个元素，然后返回一个和slice一样类型的slice
        * copy 函数copy从源slice的src中复制元素到目标dst，并且返回复制的元素的个数

* map
    *  `map[keyType]valueType`

    * map 的读取和设置也类似 slice 一样, 通过 key 来操作
        * 只是 slice 的 index 只能是 `int` 类型 
        * 而 map 多了很多类型, 可以是 int, 可以是 string 及所有完全定义了 == 与 != 操作的类型

    * eg:
        ```go
        // 声明一个key是字符串，值为int的字典,这种方式的声明需要在使用之前使用make初始化
        var numbers map[string]int

        // 另一种map的声明方式
        numbers := make(map[string]int)
        numbers["one"] = 1  //赋值
        numbers["ten"] = 10 //赋值
        numbers["three"] = 3

        fmt.Println("第三个数字是: ", numbers["three"]) // 读取数据
        // 打印出来如:第三个数字是: 3
        ```    
    * 使用map过程中需要注意的几点
        * map 是无序的，每次打印出来的 map 都会不一样，它不能通过index获取，而**必须**通过key获取
        * map 的长度是不固定的，也就是和slice一样，也是一种 **引用类型**
        * 内置的 len 函数同样适用于 map ，返回 map 拥有的 key 的数量
        * map 的值可以很方便的修改，通过 numbers["one"]=11 可以很容易的把key为one的字典值改为11
        * map 和其他基本型别不同，*它不是thread-safe*，在多个go-routine存取时，必须使用mutex lock机制
    
    * map的初始化可以通过key:val的方式初始化值，同时map内置有判断是否存在key的方式, 通过delete删除map的元素
        ```go
        // 初始化一个字典
        rating := map[string]float32{"C":5, "Go":4.5, "Python":4.5, "C++":2 }

        // map **有两个返回值** ，第二个返回值，如果不存在key，那么ok为false，如果存在ok为true
        csharpRating, ok := rating["C#"]

        if ok {
            fmt.Println("C# is in the map and its rating is ", csharpRating)
        } else {
            fmt.Println("We have no rating associated with C# in the map")
        }

        delete(rating, "C")  // 删除key为C的元素
        ```

* make、new 操作
    * make 用于内建类型（map、slice 和channel）的 *内存分配*。
    
    * new 用于各种类型的内存分配

    * `new(T)` 分配了零值填充的 T类型 的内存空间，并且 *返回其地址*，即一个 `*T`类型 的值
        * 用 Go 的术语说，它 **返回了一个指针**，指向新分配的类型 T 的零值

        * **new 返回指针**

    * 内建函数 make(T, args) 与 new(T) 有着不同的功能，make 只能创建 slice、map和channel，并且返回一个有初始值(非零)的 T类型，而不是 *T        

* 零值
```go
int     0
int8    0
int32   0
int64   0
uint    0x0
rune    0 //rune的实际类型是 int32
byte    0x0 // byte的实际类型是 uint8
float32 0 //长度为 4 byte
float64 0 //长度为 8 byte
bool    false
string  ""
```

### 2.3. 流程和函数


### 2.4. struct


### 2.5. 面向对象


### 2.6. interface


### 2.7. 并发


### 2.8. 小结

