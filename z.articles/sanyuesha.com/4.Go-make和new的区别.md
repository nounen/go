## 原文 -- Go make 和 new 的区别
* http://sanyuesha.com/2017/07/26/go-make-and-new/

* new 和 make 都可以用来 _分配空间，初始化类型_，但是它们确有不同。

### new(T) 返回的是 T 的指针
* `new(T)` 为一个 T 类型新值 _分配空间_ 并将此空间 _初始化为 T 的零值_，__返回的是新值的地址__，也就是 _T 类型的指针 *T，该指针指向 T 的新分配的零值_。
    ```go
    p1 := new(int)
    fmt.Printf("p1 --> %#v \n ", p1) //(*int)(0xc42000e250) 
    fmt.Printf("p1 point to --> %#v \n ", *p1) //0

    var p2 *int
    i := 0
    p2 = &i
    fmt.Printf("p2 --> %#v \n ", p2) //(*int)(0xc42000e278) 
    fmt.Printf("p2 point to --> %#v \n ", *p2) //0
    ```

    * 上面的代码是等价的，`new(int)` 将分配的空间初始化为 int 的零值，也就是 0，并返回 int 的指针，这和直接声明指针并初始化的效果是相同的。

* 个人总结 -- __`*` 星号的作用__: 要么是声明指针类型, 要么是指向指针地址的值



### make __只能__ 用于 slice,map,channel
* make 只能用于 `slice`，`map`，`channel` 三种类型，`make(T, args)` _返回的是初始化之后的 T 类型的值_，这个新值并不是 T 类型的零值，也不是指针 *T，_是经过初始化之后的 T 的引用_ (TODO: 显然这句话很难理解, 因为指针和引用居然是两个概念, 一直以为是一个概念)。
    ```go
    var s1 []int
    // nil 才是 slice 的零值
    if s1 == nil {
        fmt.Printf("s1 is nil --> %#v \n ", s1) // []int(nil)
    }

    s2 := make([]int, 3)
    if s2 == nil {
        fmt.Printf("s2 is nil --> %#v \n ", s2)
    } else {
        // make 以后 slice 里面的每个元素都有了零值
        fmt.Printf("s2 is not nill --> %#v \n ", s2)// []int{0, 0, 0}
    }
    ```

    * __slice 的零值是 nil__，使用 make 之后 slice 是一个初始化的 slice，即 slice 的长度、容量、底层指向的 array 都被 make 完成初始化，_此时 slice 内容被类型 int 的零值填充，形式是 [0 0 0]_，map 和 channel 也是类似的。


* eg2:
```go
var m1 map[int]string
if m1 == nil {
    fmt.Printf("m1 is nil --> %#v \n ", m1) //map[int]string(nil)
}

m2 := make(map[int]string)
if m2 == nil {
    fmt.Printf("m2 is nil --> %#v \n ", m2)
} else {
    fmt.Printf("m2 is not nill --> %#v \n ", m2) map[int]string{} 
}

var c1 chan string
if c1 == nil {
    fmt.Printf("c1 is nil --> %#v \n ", c1) //(chan string)(nil)
}

c2 := make(chan string)
if c2 == nil {
    fmt.Printf("c2 is nil --> %#v \n ", c2)
} else {
    fmt.Printf("c2 is not nill --> %#v \n ", c2)//(chan string)(0xc420016120)
}
```


### make(T, args) 返回的是 T 的 引用
* 如果不特殊声明，_go 的函数默认都是按值穿参_，即通过函数传递的参数是值的副本，在函数内部对值修改不影响值的本身，但是 `make(T, args)` 返回的值通过函数传递参数之后可以直接修改，__即 `map`，`slice`，`channel` 通过函数穿参之后在函数内部修改将影响函数外部的值__ (__天生引用传递__?)。
    ```go
    func modifySlice(s []int) {
        s[0] = 1
    }

    s2 := make([]int, 3)
    fmt.Printf("%#v", s2) //[]int{0, 0, 0}
    // 此处 map 天生引用传递?
    modifySlice(s2)

    fmt.Printf("%#v", s2) //[]int{1, 0, 0} -- TODO: slice 元素被修改了
    ```

* 这说明 `make(T, args)` 返回的是 __引用类型__ (TODO: 非常重要)，在函数内部可以直接更改原始值，对 map 和 channel 也是如此。
