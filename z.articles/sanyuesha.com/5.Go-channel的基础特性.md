## 原文 -- Go channel 的基础特性
* http://sanyuesha.com/2017/08/03/go-channel/


### 什么是 goroutine
> They’re called goroutines because the existing terms — threads, coroutines, processes, and so on — convey inaccurate connotations. A goroutine has a simple model: it is a function executing in parallel with other goroutines in the same address space. It is lightweight, costing little more than the allocation of stack space. And the stacks start small, so they are cheap, and grow by allocating (and freeing) heap storage as required.

* 正如官方所言，goroutine 是一个轻量级的执行单元，_相比线程开销更小_，完全由 Go 语言负责调度，是 Go 支持并发的核心。开启一个 goroutine 非常简单:
```go
package main

import (
	"fmt"
	"time"
)

func main() {
	go fmt.Println("goroutine message")
	time.Sleep(1) //1
	fmt.Println("main function message")
}
```

* #1 的代码是必须的，这是为了让新开启的 goroutine 有机会得到执行，开启一个 goroutine 之后，后续的代码会继续执行，在上面的例子中后续代码执行完毕程序就终止了，_而开启的 goroutine 可能还没开始执行_。

* 如果尝试去掉 #1 处的代码，程序也可能会正常运行，这是因为恰巧开启的 goroutine 只是简单的执行了一次输出，如果 goroutine 中耗时稍长就会导致只能看到主一句 `main function message`。

* 换句话话说，这里的 `time.sleep` 提供的是一种调度机制，这也是 Go 中 channel 存在的目的：负责消息传递和调度。
