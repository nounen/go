## 4.5 基本类型和运算符


### 布尔类型 bool
* eg: `var b bool = true`


### 逻辑运算符:
* 非运算符：`!`

* 和运算符：`&&`

* 或运算符：`||`


### 数字类型

#### 整型 int 和浮点型 float
* 整数：`int8, int16, int32, int64`

* 无符号整数: `uint8, uint16, uint32, uint64`

* 浮点型（IEEE-754 标准）: `float32, float64`
    * float32 精确到小数点后 7 位，float64 精确到小数点后 15 位

    * 由于精确度的缘故，你在使用 == 或者 != 来比较浮点数时应当非常小心
    
    * 你应该 **尽可能地使用 float64**，因为 math 包中所有有关数学运算的函数都会要求接收这个类型

* 整型的零值为 `0`，浮点型的零值为 `0.0`

* 八进制: 增加前缀 0 来表示 8 进制数（如：077）

* 十六进制: 增加前缀 0x 来表示 16 进制数（如：0xFF）

* e 计数法: 使用 e 来表示 10 的连乘（如： 1e3 = 1000，或者 6.022e23 = 6.022 x 1e23）


#### 格式化说明符
* `%d` 用于格式化整数（%x 和 %X 用于格式化 16 进制表示的数字）

* `%g` 用于格式化浮点型（%f 输出浮点数，%e 输出科学计数表示法）

* `%0d` 用于规定输出定长的整数，其中开头的数字 0 是必须的

* `%n.mg` 用于表示数字 n 并精确到小数点后 m 位，除了使用 g 之外，还可以使用 e 或者 f，例如：使用格式化字符串 `%5.2e` 来输出 3.4 的结果为 `3.40e+00`


### 复数
* complex64 (32 位实数和虚数)

* complex128 (64 位实数和虚数)

* 复数使用 `re+imI` 来表示，其中 `re` 代表实数部分，`im` 代表虚数部分，`I` 代表根号负 1

* 使用格式化说明符时，可以使用 `%v` 来表示复数，但当你希望只表示其中的一个部分的时候需要使用 `%f`

* TODO: 什么情况下会用到复数?


### 位运算符 (TODO: 这章几乎没看懂, 以及什么情况下使用)
* 位运算只能用于整数类型的变量，且需当它们拥有等长位模式时

* `%b` 是用于表示位的格式化标识符

#### 二元运算符
* 按位与 `&`: 对应位置上的值经过和运算结果，具体参见 *和运算符*
```go
1 & 1 -> 1
1 & 0 -> 0
0 & 1 -> 0
0 & 0 -> 0
```

* 按位或 `|`: 对应位置上的值经过或运算结果，具体参见 *或运算符*
```go
1 | 1 -> 1
1 | 0 -> 1
0 | 1 -> 1
0 | 0 -> 0
```

* 按位异或 `^`:
```go
1 ^ 1 -> 0
1 ^ 0 -> 1
0 ^ 1 -> 1
0 ^ 0 -> 0
```

* 位清除 `&^`：将指定位置上的值设置为 0


#### 一元运算符
* 按位补足 `^`

* 位左移 `<<`

* 位右移 `>>`


### 逻辑运算符
* Go 中拥有以下逻辑运算符：`==、!=`（第 4.5.1 节）、`<、<=、>、>=`

### 算术运算符
* 常见可用于整数和浮点数的二元运算符有 `+、-、*、/`

### 随机数
* rand 包

### 类型别名 (不太推荐, 看着难受)
* 在 `type TZ int` `中，TZ` 就是 `int` 类型的新名称(**别名**)


### 字符类型
* 严格来说，这并不是 Go 语言的一个类型， **字符只是整数的特殊用例**
    * `byte` 类型是 `uint8` 的别名，对于只占用 1 个字节的传统 ASCII 编码的字符来说，完全没有问题。
    
    * 例如：var ch byte = 'A'；字符使用 *单引号* 括起来

* 在 ASCII 码表中，A 的值是 65，而使用 16 进制表示则为 41，所以下面的写法是等效的：
    * `var ch byte = 65 或 var ch byte = '\x41'`


* Go 同样支持 **Unicode（UTF-8）**，因此字符同样称为 Unicode 代码点或者 runes，并在内存中使用 int 来表示
    *  `rune` 也是 Go 当中的一个类型，并且是 `int32` 的别名

    * 在书写 Unicode 字符时，需要在 16 进制数之前加上前缀 `\u` 或者 `\U`

    * 因为 Unicode 至少占用 2 个字节，所以我们使用 `int16` 或者 `int` 类型来表示

* eg:
```go
var ch int = '\u0041'
var ch2 int = '\u03B2'
var ch3 int = '\U00101234'
fmt.Printf("%d - %d - %d\n", ch, ch2, ch3) // integer: 65 - 946 - 1053236
fmt.Printf("%c - %c - %c\n", ch, ch2, ch3) // character: A - β - r
fmt.Printf("%X - %X - %X\n", ch, ch2, ch3) // UTF-8 bytes: 41 - 3B2 - 101234
fmt.Printf("%U - %U - %U", ch, ch2, ch3) // UTF-8 code point: U+0041 - U+03B2 - U+101234
```

* 格式化说明符 `%c` 用于表示字符；当和字符配合使用时，`%v` 或 `%d` 会输出用于表示该字符的整数；`%U` 输出格式为 U+hhhh 的字符串

* 包 unicode 包含了一些针对测试字符的非常有用的函数（其中 ch 代表字符）：
    * 判断是否为字母：`unicode.IsLetter(ch)`
    * 判断是否为数字：`unicode.IsDigit(ch)`
    * 判断是否为空白符号：`unicode.IsSpace(ch)`
